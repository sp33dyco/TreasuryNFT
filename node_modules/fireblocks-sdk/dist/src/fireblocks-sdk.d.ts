import { ApiClient } from "./api-client";
import { IAuthProvider } from "./iauth-provider";
import { AllocateFundsRequest, AssetResponse, AssetTypeResponse, CancelTransactionResponse, ConvertExchangeAssetResponse, CreateTransactionResponse, DeallocateFundsRequest, DepositAddressResponse, EstimateFeeResponse, EstimateTransactionFeeResponse, ExchangeResponse, ExternalWalletAsset, FiatAccountResponse, GasStationInfo, GenerateAddressResponse, InternalWalletAsset, MaxSpendableAmountResponse, MaxBip44IndexUsedResponse, NetworkConnectionResponse, OffExchangeEntityResponse, OperationSuccessResponse, PagedVaultAccountsRequestFilters, PagedVaultAccountsResponse, PublicKeyInfoArgs, PublicKeyInfoForVaultAccountArgs, RequestOptions, ResendWebhooksResponse, TransactionArguments, TransactionFilter, TransactionPageFilter, TransactionPageResponse, TransactionResponse, User, ValidateAddressResponse, VaultAccountResponse, VaultAssetResponse, VaultBalancesFilter, WalletContainerResponse, SetFeePayerConfiguration, FeePayerConfiguration, CreateWeb3ConnectionResponse, Session, NetworkConnectionRoutingPolicy, NetworkIdRoutingPolicy, NetworkIdResponse, TimePeriod, AuditsResponse, NFTOwnershipFilter, NFTOwnedAssetsFilter, Token, TokenWithBalance, Web3PagedResponse, CreateWalletConnectPayload, Web3ConnectionType, GetWeb3ConnectionsPayload, PublicKeyResponse, AllocateFundsResponse, SettleOffExchangeAccountResponse, AddCollateralTransactionRequest, RemoveCollateralTransactionRequest, GetSettlementTransactionsResponse, SettlementRequest, SettlementResponse, GetNFTsFilter, PublicKeyInformation, DropTransactionResponse, TokenLink, TokenLinkPermissionEntry, IssueTokenRequest, NFTOwnershipStatus, NFTOwnedCollectionsFilter, CollectionOwnership, TravelRuleOptions, ValidateTravelRuleVaspInfo, ValidateTravelRuleResult, ValidateCreateTravelRuleTransaction, ValidateFullTravelRuleResult, TravelRuleVasp, TravelRuleVaspFilter, TravelRuleEncryptionOptions, SmartTransfersTicketResponse, SmartTransfersTicketCreatePayload, SmartTransfersTicketsResponse, SmartTransfersTicketsFilters, SmartTransfersTicketTermPayload, SmartTransfersTicketTermFundPayload, SmartTransfersTicketTermResponse, SmartTransfersUserGroupsResponse, UsersGroup, ContractUploadRequest, ContractTemplateDto, PendingTokenLinkDto } from "./types";
import { AxiosProxyConfig, AxiosResponse } from "axios";
import { NcwSdk } from "./ncw-sdk";
export * from "./types";
export interface SDKOptions {
    /** HTTP request timeout */
    timeoutInMs?: number;
    /** Proxy configurations */
    proxy?: AxiosProxyConfig | false;
    /** Whether to remove platform from User-Agent header */
    anonymousPlatform?: boolean;
    /** Additional product identifier to be prepended to the User-Agent header */
    userAgent?: string;
    /**
     * Providing custom axios options including a response interceptor (https://axios-http.com/docs/interceptors)
     */
    customAxiosOptions?: {
        interceptors?: {
            response?: {
                onFulfilled: (value: AxiosResponse<any, any>) => AxiosResponse<any, any> | Promise<AxiosResponse<any, any>>;
                onRejected: (error: any) => any;
            };
        };
    };
    /**
     * TravelRule Provider options to initialize PII Client for PII encryption
     */
    travelRuleOptions?: TravelRuleOptions;
}
export declare class FireblocksSDK {
    private readonly authProvider;
    private readonly apiBaseUrl;
    private readonly apiClient;
    private readonly apiNcw;
    private piiClient;
    /**
     * Creates a new Fireblocks API Client
     * @param privateKey A string representation of your private key
     * @param apiKey Your api key. This is a uuid you received from Fireblocks
     * @param apiBaseUrl The fireblocks server URL. Leave empty to use the default server
     * @param authProvider
     * @param sdkOptions
     */
    constructor(privateKey: string, apiKey: string, apiBaseUrl?: string, authProvider?: IAuthProvider, sdkOptions?: SDKOptions);
    /**
     * NCW API Namespace
     *
     * @readonly
     * @type {NcwSdk}
     */
    get NCW(): NcwSdk;
    /**
     * Get the instance of ApiClient used by the FireblocksSDK
     */
    getApiClient(): ApiClient;
    /**
     * Gets all assets that are currently supported by Fireblocks
     */
    getSupportedAssets(): Promise<AssetTypeResponse[]>;
    /**
     * Gets a list of vault accounts per page matching the given filter or path
     * @param pagedVaultAccountsRequestFilters Filters for the first request
     */
    getVaultAccountsWithPageInfo(pagedVaultAccountsRequestFilters: PagedVaultAccountsRequestFilters): Promise<PagedVaultAccountsResponse>;
    /**
     * Gets a single vault account
     * @param vaultAccountId The vault account ID
     */
    getVaultAccountById(vaultAccountId: string): Promise<VaultAccountResponse>;
    /**
     * Gets a single vault account asset
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset to get
     */
    getVaultAccountAsset(vaultAccountId: string, assetId: string): Promise<AssetResponse>;
    /**
     * Gets a single vault account asset balance after forcing refresh from the blockchain
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset to get
     * @param requestOptions
     */
    refreshVaultAssetBalance(vaultAccountId: string, assetId: string, requestOptions?: RequestOptions): Promise<AssetResponse>;
    /**
     * Gets deposit addresses for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to get the deposit address
     */
    getDepositAddresses(vaultAccountId: string, assetId: string): Promise<DepositAddressResponse[]>;
    /**
     * Gets utxo list for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to get the utxo list
     */
    getUnspentInputs(vaultAccountId: string, assetId: string): Promise<DepositAddressResponse[]>;
    /**
     * Generates a new address for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to generate the deposit address
     * @param description A description for the new address
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    generateNewAddress(vaultAccountId: string, assetId: string, description?: string, customerRefId?: string, requestOptions?: RequestOptions): Promise<GenerateAddressResponse>;
    /**
     * Sets the description of an existing address
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset
     * @param address The address for which to set the description
     * @param tag The XRP tag, or EOS memo, for which to set the description
     * @param description The description to set
     */
    setAddressDescription(vaultAccountId: string, assetId: string, address: string, tag?: string, description?: string): Promise<OperationSuccessResponse>;
    /**
     * Gets all network connections
     * @returns NetworkConnectionResponse
     */
    getNetworkConnections(): Promise<NetworkConnectionResponse[]>;
    /**
     * Creates a network connection
     * @param localNetworkId The local netowrk profile's id
     * @param remoteNetworkId The remote network profile's id
     * @param routingPolicy The desired routing policy for the connection
     * @returns NetworkConnectionResponse
     */
    createNetworkConnection(localNetworkId: string, remoteNetworkId: string, routingPolicy?: NetworkConnectionRoutingPolicy): Promise<NetworkConnectionResponse>;
    /**
     * Gets a single network connection
     * @param connectionId The network connection's id
     * @returns NetworkConnectionResponse
     */
    getNetworkConnectionById(connectionId: string): Promise<NetworkConnectionResponse>;
    /**
     * Removes a network connection
     * @param connectionId The network connection's id
     * @returns OperationSuccessResponse
     */
    removeNetworkConnection(connectionId: string): Promise<OperationSuccessResponse>;
    /**
     * Sets routing policy for a network connection
     * @param connectionId The network connection's id
     * @param routingPolicy The desired routing policy
     */
    setNetworkConnectionRoutingPolicy(connectionId: string, routingPolicy: NetworkConnectionRoutingPolicy): Promise<void>;
    /**
     * Gets all discoverable network profiles
     * @returns NetworkIdResponse
     */
    getDiscoverableNetworkIds(): Promise<NetworkIdResponse[]>;
    /**
     * Creates a new network profile
     * @param name A name for the new network profile
     * @param routingPolicy The desired routing policy for the network
     * @returns NetworkConnectionResponse
     */
    createNetworkId(name: string, routingPolicy?: NetworkIdRoutingPolicy): Promise<NetworkIdResponse>;
    /**
     * Gets a single network profile
     * @param networkId The network profile's id
     * @returns NetworkIdResponse
     */
    getNetworkId(networkId: string): Promise<NetworkIdResponse>;
    /**
     * Deletes a single network profile
     * @param networkId The network profile's id
     * @returns NetworkIdResponse
     */
    deleteNetworkId(networkId: string): Promise<OperationSuccessResponse>;
    /**
     * Sets discoverability for network profile
     * @param networkId The network profile's id
     * @param isDiscoverable The desired discoverability to set
     * @returns OperationSuccessResponse
     */
    setNetworkIdDiscoverability(networkId: string, isDiscoverable: boolean): Promise<OperationSuccessResponse>;
    /**
     * Sets routing policy for network profile
     * @param networkId The network profile's id
     * @param routingPolicy The desired routing policy
     * @returns OperationSuccessResponse
     */
    setNetworkIdRoutingPolicy(networkId: string, routingPolicy: NetworkIdRoutingPolicy): Promise<void>;
    /**
     * Sets network profile name
     * @param networkId The network profile's id
     * @param name The desired network profile's name
     * @returns OperationSuccessResponse
     */
    setNetworkIdName(networkId: string, name: string): Promise<void>;
    /**
     * Gets all exchange accounts for your tenant
     */
    getExchangeAccounts(): Promise<ExchangeResponse[]>;
    /**
     * Gets a single exchange account by ID
     * @param exchangeAccountId The exchange account ID
     */
    getExchangeAccountById(exchangeAccountId: string): Promise<ExchangeResponse>;
    /**
     * Gets a single asset within an Exchange Account
     * @param exchangeAccountId The exchange account ID
     * @param assetId The ID of the asset
     */
    getExchangeAsset(exchangeAccountId: string, assetId: string): Promise<AssetResponse>;
    /**
     * Convert an asset at an Exchange Account
     * @param exchangeAccountId The exchange account ID
     * @param srcAsset The source asset to convert from
     * @param destAsset The destination asset to convert to
     * @param amount The amount to convert
     */
    convertExchangeAsset(exchangeAccountId: string, srcAsset: string, destAsset: string, amount: number, requestOptions?: RequestOptions): Promise<ConvertExchangeAssetResponse>;
    /**
     * Transfer from a main exchange account to a subaccount
     * @param exchangeAccountId The exchange ID in Fireblocks
     * @param subaccountId The ID of the subaccount in the exchange
     * @param assetId The asset to transfer
     * @param amount The amount to transfer
     * @param requestOptions
     */
    transferToSubaccount(exchangeAccountId: string, subaccountId: string, assetId: string, amount: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Transfer from a subaccount to a main exchange account
     * @param exchangeAccountId The exchange ID in Fireblocks
     * @param subaccountId The ID of the subaccount in the exchange
     * @param assetId The asset to transfer
     * @param amount The amount to transfer
     * @param requestOptions
     */
    transferFromSubaccount(exchangeAccountId: string, subaccountId: string, assetId: string, amount: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Gets all fiat accounts for your tenant
     */
    getFiatAccounts(): Promise<FiatAccountResponse[]>;
    /**
     * Gets a single fiat account by ID
     * @param accountId The fiat account ID
     */
    getFiatAccountById(accountId: string): Promise<FiatAccountResponse>;
    /**
     * Redeem from a fiat account to a linked DDA
     * @param accountId The fiat account ID in Fireblocks
     * @param amount The amount to transfer
     * @param requestOptions
     */
    redeemToLinkedDDA(accountId: string, amount: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Deposit to a fiat account from a linked DDA
     * @param accountId The fiat account ID in Fireblocks
     * @param amount The amount to transfer
     * @param requestOptions
     */
    depositFromLinkedDDA(accountId: string, amount: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Gets a list of transactions matching the given filter
     * @param filter.before Only gets transactions created before a given timestamp (in milliseconds)
     * @param filter.after Only gets transactions created after a given timestamp (in milliseconds)
     * @param filter.status Only gets transactions with the spcified status
     * @param filter.limit Limit the amount of returned results. If not specified, a limit of 200 results will be used
     * @param filter.orderBy Determines the order of the results
     */
    getTransactions(filter: TransactionFilter): Promise<TransactionResponse[]>;
    /**
     * Gets a list of transactions per page matching the given filter or path
     * @param pageFilter Get transactions matching pageFilter params
     * @param nextOrPreviousPath Get transactions from each of pageDetails paths
     */
    getTransactionsWithPageInfo(pageFilter?: TransactionPageFilter, nextOrPreviousPath?: string): Promise<TransactionPageResponse>;
    /**
     * Gets a transaction matching the external transaction id provided
     * @param externalTxId
     */
    getTransactionByExternalTxId(externalTxId: string): Promise<TransactionResponse>;
    /**
     * Gets all internal wallets for your tenant
     */
    getInternalWallets(): Promise<WalletContainerResponse<InternalWalletAsset>[]>;
    /**
     * Gets a single internal wallet
     * @param walletId The internal wallet ID
     */
    getInternalWallet(walletId: string): Promise<WalletContainerResponse<InternalWalletAsset>>;
    /**
     * Gets a single internal wallet asset
     * @param walletId The internal wallet ID
     * @param assetId The asset ID
     */
    getInternalWalletAsset(walletId: string, assetId: string): Promise<InternalWalletAsset>;
    /**
     * Gets all external wallets for your tenant
     */
    getExternalWallets(): Promise<WalletContainerResponse<ExternalWalletAsset>[]>;
    /**
     * Gets a single external wallet
     * @param walletId The external wallet ID
     */
    getExternalWallet(walletId: string): Promise<WalletContainerResponse<ExternalWalletAsset>>;
    /**
     * Gets a single external wallet asset
     * @param walletId The external wallet ID
     * @param assetId The asset ID
     */
    getExternalWalletAsset(walletId: string, assetId: string): Promise<ExternalWalletAsset>;
    /**
     * Gets all contract wallets for your tenant
     */
    getContractWallets(): Promise<WalletContainerResponse<ExternalWalletAsset>[]>;
    /**
     * Gets a single contract wallet
     * @param walletId The contract wallet ID
     */
    getContractWallet(walletId: string): Promise<WalletContainerResponse<ExternalWalletAsset>>;
    /**
     * Gets a single contract wallet asset
     * @param walletId The contract wallet ID
     * @param assetId The asset ID
     */
    getContractWalletAsset(walletId: string, assetId: string): Promise<ExternalWalletAsset>;
    /**
     * Gets detailed information for a single transaction
     * @param txId The transaction id to query
     */
    getTransactionById(txId: string): Promise<TransactionResponse>;
    /**
     * Cancels the selected transaction
     * @param txId The transaction id to cancel
     * @param requestOptions
     */
    cancelTransactionById(txId: string, requestOptions?: RequestOptions): Promise<CancelTransactionResponse>;
    /**
     * Creates a new vault account
     * @param name A name for the new vault account
     * @param hiddenOnUI If true, the created account and all related transactions will not be shown on Fireblocks console
     * @param customerRefId A customer reference ID
     * @param autoFuel
     * @param requestOptions
     * @param autoFuel
     * @param requestOptions
     */
    createVaultAccount(name: string, hiddenOnUI?: boolean, customerRefId?: string, autoFuel?: boolean, requestOptions?: RequestOptions): Promise<VaultAccountResponse>;
    /**
     * Hides a vault account in Fireblocks console
     * @param vaultAccountId The vault account ID
     * @param requestOptions
     */
    hideVaultAccount(vaultAccountId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Reveals a hidden vault account in Fireblocks console
     * @param vaultAccountId The vault account ID
     * @param requestOptions
     */
    unhideVaultAccount(vaultAccountId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Sets autoFuel to true/false for a vault account
     * @param vaultAccountId The vault account ID
     * @param autoFuel The new value for the autoFuel flag
     * @param requestOptions
     */
    setAutoFuel(vaultAccountId: string, autoFuel: boolean, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Updates a vault account
     * @param vaultAccountId
     * @param name A new name for the vault account
     */
    updateVaultAccount(vaultAccountId: string, name: string): Promise<VaultAccountResponse>;
    /**
     * Creates a new asset within an existing vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The asset to add
     * @param requestOptions
     */
    createVaultAsset(vaultAccountId: string, assetId: string, requestOptions?: RequestOptions): Promise<VaultAssetResponse>;
    /**
     * Retry to create a vault asset for a vault asset that failed
     * @param vaultAccountId The vault account ID
     * @param assetId The asset to add
     * @param requestOptions
     */
    activateVaultAsset(vaultAccountId: string, assetId: string, requestOptions?: RequestOptions): Promise<VaultAssetResponse>;
    /**
     * Creates a new external wallet
     * @param name A name for the new external wallet
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    createExternalWallet(name: string, customerRefId?: string, requestOptions?: RequestOptions): Promise<WalletContainerResponse<ExternalWalletAsset>>;
    /**
     * Creates a new internal wallet
     * @param name A name for the new internal wallet
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    createInternalWallet(name: string, customerRefId?: string, requestOptions?: RequestOptions): Promise<WalletContainerResponse<InternalWalletAsset>>;
    /**
     * Creates a new contract wallet
     * @param name A name for the new contract wallet
     */
    createContractWallet(name: string, requestOptions?: RequestOptions): Promise<WalletContainerResponse<ExternalWalletAsset>>;
    /**
     * Creates a new asset within an exiting external wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     * @param requestOptions
     */
    createExternalWalletAsset(walletId: string, assetId: string, address: string, tag?: string, requestOptions?: RequestOptions): Promise<ExternalWalletAsset>;
    /**
     * Creates a new asset within an exiting internal wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     * @param requestOptions
     */
    createInternalWalletAsset(walletId: string, assetId: string, address: string, tag?: string, requestOptions?: RequestOptions): Promise<InternalWalletAsset>;
    /**
     * Creates a new asset within an exiting contract wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     */
    createContractWalletAsset(walletId: string, assetId: string, address: string, tag?: string, requestOptions?: RequestOptions): Promise<ExternalWalletAsset>;
    /**
     * Creates a new transaction with the specified options
     */
    createTransaction(transactionArguments: TransactionArguments, requestOptions?: RequestOptions, travelRuleEncryptionOptions?: TravelRuleEncryptionOptions): Promise<CreateTransactionResponse>;
    /**
     * Estimates the fee for a transaction request
     */
    estimateFeeForTransaction(transactionArguments: TransactionArguments, requestOptions?: RequestOptions): Promise<EstimateTransactionFeeResponse>;
    /**
     * Gets the estimated fees for an asset
     */
    getFeeForAsset(asset: string): Promise<EstimateFeeResponse>;
    /**
     * Deletes a single internal wallet
     * @param walletId The internal wallet ID
     */
    deleteInternalWallet(walletId: string): Promise<OperationSuccessResponse>;
    /**
     * Deletes a single internal wallet asset
     * @param walletId The internal wallet ID
     * @param assetId The asset ID
     */
    deleteInternalWalletAsset(walletId: string, assetId: string): Promise<OperationSuccessResponse>;
    /**
     * Deletes a single external wallet
     * @param walletId The external wallet ID
     */
    deleteExternalWallet(walletId: string): Promise<OperationSuccessResponse>;
    /**
     * Deletes a single external wallet asset
     * @param walletId The external wallet ID
     * @param assetId The asset ID
     */
    deleteExternalWalletAsset(walletId: string, assetId: string): Promise<OperationSuccessResponse>;
    /**
     * Deletes a single contract wallet
     * @param walletId The contract wallet ID
     */
    deleteContractWallet(walletId: string): Promise<OperationSuccessResponse>;
    /**
     * Deletes a single contract wallet asset
     * @param walletId The contract wallet ID
     * @param assetId The asset ID
     */
    deleteContractWalletAsset(walletId: string, assetId: string): Promise<OperationSuccessResponse>;
    /**
     * Sets a customer reference ID
     * @param vaultAccountId The vault account ID
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForVaultAccount(vaultAccountId: string, customerRefId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Sets a customer reference ID
     * @param walletId The ID of the internal wallet
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForInternalWallet(walletId: string, customerRefId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Sets a customer reference ID
     * @param walletId The ID of the external wallet
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForExternalWallet(walletId: string, customerRefId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Sets a customer reference ID
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset
     * @param address The address
     * @param tag The XRP tag, or EOS memo
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForAddress(vaultAccountId: string, assetId: string, address: string, tag?: string, customerRefId?: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Set the required number of confirmations for transaction
     * @param txId
     * @param requiredConfirmationsNumber
     * @param requestOptions
     */
    setConfirmationThresholdForTxId(txId: string, requiredConfirmationsNumber: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Set the required number of confirmations for transactions by tx hash
     * @param txHash
     * @param requiredConfirmationsNumber
     * @param requestOptions
     */
    setConfirmationThresholdForTxHash(txHash: string, requiredConfirmationsNumber: number, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Get the public key information
     * @param args
     */
    getPublicKeyInfo(args: PublicKeyInfoArgs): Promise<PublicKeyInformation>;
    /**
     * allocate funds from you default balance to a private ledger
     * @param vaultAccountId
     * @param asset
     * @param vaultAccountId
     * @param asset
     * @param args
     * @param requestOptions
     */
    allocateFundsToPrivateLedger(vaultAccountId: string, asset: string, args: AllocateFundsRequest, requestOptions?: RequestOptions): Promise<AllocateFundsResponse>;
    /**
     * deallocate funds from a private ledger to your default balance
     * @param vaultAccountId
     * @param asset
     * @param args
     * @param requestOptions
     */
    deallocateFundsFromPrivateLedger(vaultAccountId: string, asset: string, args: DeallocateFundsRequest, requestOptions?: RequestOptions): Promise<AllocateFundsResponse>;
    /**
     * Get the public key information for a vault account
     * @param args
     */
    getPublicKeyInfoForVaultAccount(args: PublicKeyInfoForVaultAccountArgs): Promise<PublicKeyResponse>;
    /**
     * Get configuration and status of the Gas Station account
     */
    getGasStationInfo(assetId?: string): Promise<GasStationInfo>;
    /**
     * Set configuration of the Gas Station account
     */
    setGasStationConfiguration(gasThreshold: string, gasCap: string, maxGasPrice?: string, assetId?: string): Promise<OperationSuccessResponse>;
    /**
     * Drop an ETH based transaction
     */
    dropTransaction(txId: string, feeLevel?: string, requestedFee?: string, requestOptions?: RequestOptions): Promise<DropTransactionResponse>;
    /**
     * Get max spendable amount per asset and vault
     */
    getMaxSpendableAmount(vaultAccountId: string, assetId: string, manualSigning?: Boolean): Promise<MaxSpendableAmountResponse>;
    /**
     * Get maximum BIP44 index used in deriving addresses or in change addresses
     */
    getMaxBip44IndexUsed(vaultAccountId: string, assetId: string): Promise<MaxBip44IndexUsedResponse>;
    /**
     * Get all vault assets balance overview
     */
    getVaultAssetsBalance(filter: VaultBalancesFilter): Promise<AssetResponse[]>;
    /**
     * Get vault balance overview per asset
     */
    getVaultBalanceByAsset(assetId: string): Promise<AssetResponse>;
    /**
     * Get address validation info
     */
    validateAddress(assetId: string, address: string): Promise<ValidateAddressResponse>;
    /**
     * Unfreezes the selected transaction
     * @param txId The transaction id to unfreeze
     * @param requestOptions
     */
    unfreezeTransactionById(txId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Freezes the selected transaction
     * @param txId The transaction id to freeze
     * @param requestOptions
     */
    freezeTransactionById(txId: string, requestOptions?: RequestOptions): Promise<OperationSuccessResponse>;
    /**
     * Resend failed webhooks
     */
    resendWebhooks(requestOptions?: RequestOptions): Promise<ResendWebhooksResponse>;
    /**
     * Resend transaction webhooks
     * @param txId The transaction for which the message is sent
     * @param resendCreated If true a webhook will be sent for the creation of the transaction
     * @param resendStatusUpdated If true a webhook will be sent for the status of the transaction
     * @param requestOptions
     */
    resendTransactionWebhooksById(txId: string, resendCreated?: boolean, resendStatusUpdated?: boolean, requestOptions?: RequestOptions): Promise<ResendWebhooksResponse>;
    /**
     * Gets all Users for your tenant
     */
    getUsers(): Promise<User[]>;
    /**
     * Gets all Users Groups for your tenant
     */
    getUsersGroups(): Promise<UsersGroup[]>;
    /**
     * Gets a Users Group by ID
     * @param id The ID of the User
     */
    getUsersGroup(id: string): Promise<UsersGroup>;
    /**
     * Creates a new Users Group
     * @param name The name of the Users Group
     * @param memberIds The members of the Users Group
     */
    createUserGroup(groupName: string, memberIds?: string[]): Promise<UsersGroup>;
    /**
     * Updates a Users Group
     * @param id The ID of the Users Group
     * @param name The name of the Users Group
     * @param memberIds The members of the Users Group
     */
    updateUserGroup(id: string, groupName?: string, memberIds?: string[]): Promise<UsersGroup>;
    /**
     * Deletes a Users Group
     * @param id The ID of the Users Group
     */
    deleteUserGroup(id: string): Promise<void>;
    /**
     * Get off exchange accounts
     */
    getOffExchangeAccounts(): Promise<OffExchangeEntityResponse[]>;
    /**
     * Get off exchange account by virtual account id
     * @param id the ID of the off exchange
     */
    getOffExchangeAccountById(id: string): Promise<OffExchangeEntityResponse>;
    /**
     * Settle off exchange account by virtual account id
     * @param id the ID of the off exchange
     * @param requestOptions
     */
    settleOffExchangeAccountById(id: string, requestOptions?: RequestOptions): Promise<SettleOffExchangeAccountResponse>;
    /**
     * Add collateral account, create deposit request
     * @param depositRequest
     * @param requestOptions
     */
    addCollateral(depositRequest: AddCollateralTransactionRequest, requestOptions?: RequestOptions): Promise<CreateTransactionResponse>;
    /**
     * Remove collateral account, create withdraw request
     * @param withdrawRequest
     * @param requestOptions
     */
    removeCollateral(withdrawRequest: RemoveCollateralTransactionRequest, requestOptions?: RequestOptions): Promise<CreateTransactionResponse>;
    /**
     *
     * @param requestOptions
     */
    getSettlementTransactions(settlementRequest: SettlementRequest): Promise<GetSettlementTransactionsResponse>;
    /**
     *
     * @param settlementRequest
     * @param requestOptions
     */
    settlement(settlementRequest: SettlementRequest, requestOptions?: RequestOptions): Promise<SettlementResponse>;
    /**
     * Set Fee Payer configuration
     * @param feePayerConfiguration
     * @param baseAsset
     * @param requestOptions
     */
    setFeePayerConfiguration(baseAsset: string, feePayerConfiguration: SetFeePayerConfiguration, requestOptions?: RequestOptions): Promise<FeePayerConfiguration>;
    /**
     * Get Fee Payer Configuration
     * @param baseAsset
     */
    getFeePayerConfiguration(baseAsset: string): Promise<FeePayerConfiguration>;
    /**
     * Delete Fee Payer Configuration
     * @param baseAsset
     */
    removeFeePayerConfiguration(baseAsset: string): Promise<void>;
    private getWeb3ConnectionPath;
    /**
     * Get all signer connections of the current tenant
     * @param {Object} payload The payload for getting the current tenant's sessions
     * @param payload.pageCursor The cursor for the next page
     * @param payload.pageSize The amount of results to return on the next page
     * @param payload.sort The property to sort the results by
     * @param payload.filter The filter object, containing properties as keys and the values to filter by as values
     * @param payload.order Should the results be ordered in ascending order (false) or descending (true)
     *
     * @returns An object containing the data returned and the cursor for the next page
     */
    getWeb3Connections({ pageCursor, pageSize, sort, filter, order }?: GetWeb3ConnectionsPayload): Promise<Web3PagedResponse<Session>>;
    /**
     * Initiate a new web3 connection
     * @param type The type of the connection
     * @param payload The payload for creating a new web3 connection
     * @param requestOptions
     * @param payload.vaultAccountId The vault account to link with the dapp
     * @param payload.feeLevel The fee level for the connection
     * @param payload.uri The WalletConnect URI, as provided by the dapp
     * @param payload.chainIds Array of the approved chains for the connection
     *
     * @returns The created session's ID and it's metadata
     * @example {
     *  vaultAccountId: 0
     *  feeLevel: "MEDIUM"
     *  connectionType: "WalletConnect"
     *  uri: "wc:77752975-906f-48f5-b59f-047826ee947e@1?bridge=https%3A%2F%2F0.bridge.walletconnect.org&key=64be99adc6086b7a729b0ec8c7e1f174927ab92e84f5c6f9527050225344a637"
     *  chainIds: ["ETH", "ETH_TEST"]
     * }
     */
    createWeb3Connection(type: Web3ConnectionType.WALLET_CONNECT, payload: CreateWalletConnectPayload, requestOptions?: RequestOptions): Promise<CreateWeb3ConnectionResponse>;
    /**
     * Approve or Reject the initiated connection
     * @param type The type of the connection
     * @param sessionId The ID of the session
     * @param approve Whether you approve the connection or not
     */
    submitWeb3Connection(type: Web3ConnectionType.WALLET_CONNECT, sessionId: string, approve: boolean): Promise<void>;
    /**
     * Remove an existing connection
     * @param type The type of the connection
     * @param sessionId The ID of the session
     */
    removeWeb3Connection(type: Web3ConnectionType.WALLET_CONNECT, sessionId: string): Promise<void>;
    /**
     * Gets all audits for selected time period
     * @param timePeriod
     */
    getAudits(timePeriod?: TimePeriod): Promise<AuditsResponse>;
    /**
     *
     * @param id
     */
    getNFT(id: string): Promise<Token>;
    /**
     *
     * @param filter.pageCursor
     * @param filter.pageSize
     * @param filter.ids
     * @param filter.sort
     * @param filter.order
     */
    getNFTs(filter: GetNFTsFilter): Promise<Web3PagedResponse<Token>>;
    /**
     *
     * Gets a list of owned NFT tokens
     * @param filter.vaultAccountIds List of vault account IDs
     * @param filter.blockchainDescriptor The blockchain descriptor (based on legacy asset)
     * @param filter.collectionIds List of collection IDs
     * @param filter.ids List of token ids to fetch
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.search Search filter
     * @param filter.ncwAccountIds List of Non-Custodial wallet account IDs
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     */
    getOwnedNFTs(filter?: NFTOwnershipFilter): Promise<Web3PagedResponse<TokenWithBalance>>;
    /**
     *
     * Get a list of owned NFT collections
     * @param filter.search Search by value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order by value
     */
    listOwnedCollections(filter?: NFTOwnedCollectionsFilter): Promise<Web3PagedResponse<CollectionOwnership>>;
    /**
     *
     * Get a list of owned tokens
     * @param filter.search Search by value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order by value
     */
    listOwnedAssets(filter?: NFTOwnedAssetsFilter): Promise<Web3PagedResponse<Token>>;
    /**
     *
     * @param id
     */
    refreshNFTMetadata(id: string): Promise<void>;
    /**
     *
     * Update NFT ownership status for specific token
     * @param id NFT asset id
     * @param status Status for update
     */
    updateNFTOwnershipStatus(id: string, status: NFTOwnershipStatus): Promise<void>;
    /**
     *
     * @param vaultAccountId
     * @param blockchainDescriptor
     */
    refreshNFTOwnershipByVault(vaultAccountId: string, blockchainDescriptor: string): Promise<void>;
    /**
     * Upload a new contract. This contract would be private and only your tenant can see it
     * @param request
     */
    uploadNewContract(request: ContractUploadRequest): Promise<ContractTemplateDto>;
    /**
     * Get all tokens linked to the tenant
     * @param limit
     * @param offset
     */
    getLinkedTokens(limit?: number, offset?: number): Promise<TokenLink[]>;
    /**
     * Issue a new token and link it to the tenant
     * @param request
     */
    issueNewToken(request: IssueTokenRequest): Promise<PendingTokenLinkDto>;
    /**
     * Get a token linked to the tenant by asset id
     * @param assetId
     */
    getLinkedToken(assetId: string): Promise<TokenLink>;
    /**
     * Link a token to the tenant
     * @param assetId
     */
    linkToken(assetId: string): Promise<TokenLink>;
    /**
     * remove a link to a token from the tenant
     * @param assetId
     */
    unlinkToken(assetId: string): Promise<TokenLink>;
    /**
     * Add permissions to a linked token
     * @param assetId
     * @param permissions
     */
    addLinkedTokenPermissions(assetId: string, permissions: TokenLinkPermissionEntry[]): Promise<TokenLink>;
    /**
     * Remove permissions from a linked token
     * @param assetId
     * @param permission
     */
    removeLinkedTokenPermissions(assetId: string, permission: TokenLinkPermissionEntry): Promise<TokenLink>;
    /**
     * Validate VASP details for travel rule compliance
     * @param travelRuleMessageVaspInfo
     */
    validateTravelRuleTransaction(travelRuleMessageVaspInfo: ValidateTravelRuleVaspInfo): Promise<ValidateTravelRuleResult>;
    /**
     * Validate Travel Rule transaction and PII data
     * @param travelRuleMessage
     */
    validateFullTravelRuleTransaction(travelRuleMessage: ValidateCreateTravelRuleTransaction): Promise<ValidateFullTravelRuleResult>;
    /**
     * Get VASP details for travel rule compliance
     * @param did
     */
    getTravelRuleVASPDetails(did: string): Promise<TravelRuleVasp>;
    /**
     * Get VASP library for travel rule compliance
     */
    getAllTravelRuleVASPs(filter?: TravelRuleVaspFilter): Promise<TravelRuleVasp[]>;
    /**
     * Update VASP for travel rule compliance
     */
    updateVasp(vaspInfo: TravelRuleVasp): Promise<TravelRuleVasp>;
    /**
     * Creates Smart Transfers ticket
     * @param data
     * @param requestOptions
     */
    createSmartTransferTicket(data: SmartTransfersTicketCreatePayload, requestOptions?: RequestOptions): Promise<SmartTransfersTicketResponse>;
    /**
     * Get Smart Transfer tickets
     * @param filters
     */
    getSmartTransferTickets(filters: SmartTransfersTicketsFilters): Promise<SmartTransfersTicketsResponse>;
    /**
     * Get Smart Transfers ticket by id
     * @param ticketId
     */
    getSmartTransferTicket(ticketId: string): Promise<SmartTransfersTicketResponse>;
    /**
     * Set Smart Transfers ticket expires in
     * @param ticketId
     * @param expiresIn
     */
    setSmartTransferTicketExpiresIn(ticketId: string, expiresIn: number): Promise<SmartTransfersTicketResponse>;
    /**
     * Set Smart Transfer ticket external id
     * @param ticketId
     * @param externalRefId
     */
    setSmartTransferTicketExternalId(ticketId: string, externalRefId: string): Promise<SmartTransfersTicketResponse>;
    /**
     * Submit Smart Transfers ticket
     * @param ticketId
     * @param expiresIn
     */
    submitSmartTransferTicket(ticketId: string, expiresIn: number): Promise<SmartTransfersTicketResponse>;
    /**
     * Fulfill Smart Transfers ticket
     * @param ticketId
     */
    fulfillSmartTransferTicket(ticketId: string): Promise<SmartTransfersTicketResponse>;
    /**
     * Cancel Smart Transfers ticket
     * @param ticketId
     */
    cancelSmartTransferTicket(ticketId: string): Promise<SmartTransfersTicketResponse>;
    /**
     * Create Smart Transfers ticket term
     * @param ticketId
     * @param data
     */
    createSmartTransferTicketTerm(ticketId: string, data: SmartTransfersTicketTermPayload): Promise<SmartTransfersTicketTermResponse>;
    /**
     * Fet Smart Transfers ticket term
     * @param ticketId
     * @param termId
     */
    getSmartTransferTicketTerms(ticketId: string, termId: string): Promise<SmartTransfersTicketTermResponse>;
    /**
     * Update Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param data
     */
    updateSmartTransferTicketTerms(ticketId: string, termId: string, data: SmartTransfersTicketTermPayload): Promise<SmartTransfersTicketTermResponse>;
    /**
     * Fund Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param data
     */
    fundSmartTransferTicketTerm(ticketId: string, termId: string, data: SmartTransfersTicketTermFundPayload): Promise<SmartTransfersTicketTermResponse>;
    /**
     * Manually fund Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param txHash
     */
    manuallyFundSmartTransferTicketTerms(ticketId: string, termId: string, txHash: string): Promise<SmartTransfersTicketTermResponse>;
    /**
     * Set Smart Transfers user group ids. User group ids are used for Smart Transfer notifications
     * @param userGroupIds
     */
    setSmartTransferTicketUserGroups(userGroupIds: string[]): Promise<SmartTransfersUserGroupsResponse>;
    /**
     * Get Smart Transfers user group ids. User group ids are used for Smart Transfer notifications
     */
    getSmartTransferTicketUserGroups(): Promise<SmartTransfersUserGroupsResponse>;
    /**
     * Delete Smart Transfers ticket term
     * @param ticketId
     * @param termId
     */
    deleteSmartTransferTicketTerms(ticketId: string, termId: string): Promise<void>;
    private getCommaSeparatedList;
}
